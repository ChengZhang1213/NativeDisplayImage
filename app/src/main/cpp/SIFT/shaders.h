//
// Created by Android on 2017/5/4.
//

#ifndef GPUSIFTANDROID_SHADERS_H
#define GPUSIFTANDROID_SHADERS_H

#include <asm/signal.h>
//Computes the descriptor

static auto desciptorFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D pic0;\n"
        "uniform int sqSize;\n"
        "void main(void)\n"
        "{\n"
        "    mediump float off = 1.0/(30.0*float(sqSize));\n"
        "    //we transform the coordinates\n"
        "    mediump vec2 case = floor(float(sqSize)*tCoord);\n"
        "    mediump vec2 sub = floor(fract(float(sqSize)*tCoord)*4.0);\n"
        "    mediump vec2 coord=case/float(sqSize)+7.01*off+4.0*sub*0.99*off;\n"
        "    //we gather values\n"
        "    mediump float bins[8];\n"
        "    for (int i=0; i<8; i++) {\n"
        "        bins[i]=0.0;\n"
        "    }\n"
        "    for (int i=0; i<4; i++) {\n"
        "        mediump float h = float(i==1 || i==2);\n"
        "        for (int j=0; j<4; j++) {\n"
        "            h += float(i==1 || i==2);\n"
        "            mediump vec4 c=texture2D(pic0,coord+vec2(float(i)*off,float(j)*off));\n"
        "            mediump float d=fract(c.x*8.0);\n"
        "            bins[int(floor(c.x*8.0))]+=(1.0-d)*c.y*(0.6+0.2*h)/64.0;\n"
        "            bins[int(mod(floor(c.x*8.0+1.0),8.0))]+=d*c.y*(0.6+0.2*h)/64.0;\n"
        "        }\n"
        "    }\n"
        "    //descriptors, with 4 bits per bin only...\n"
        "    gl_FragColor=vec4(16.0*bins[0]+bins[1], 16.0*bins[2]+bins[3], 16.0*bins[4]+bins[5], 16.0*bins[6]+bins[7]);\n"
        "}";
//substracts two gaussians to create DoG
static auto dogFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform mediump sampler2D pic;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    mediump vec4 r = vec4(texture2D(pic, tCoord).yzw-texture2D(pic, tCoord).xyz, 0.0);\n"
        "    gl_FragColor = r*6.0+0.5;\n"
        "}";
//removes edge responses and low contrast keypoints
static auto edgeSuppressionFragmentShader = "uniform mediump vec2 readingPosition;\n"
        "uniform mediump sampler2D pic0;\n"
        "uniform mediump sampler2D pic1;\n"
        "uniform mediump float width;\n"
        "uniform mediump float height;\n"
        "uniform mediump int scale;\n"
        "\n"
        "void main(void)\n"
        "{\n"
        "    mediump float offseth = 1.0/width;\n"
        "    mediump float offsetv = 1.0/height;\n"
        "    \n"
        "    mediump float thresEdge=10.0;\n"
        "    \n"
        "    mediump vec4 t[9];\n"
        "    t[0]=vec4(texture2D(pic0, readingPosition+vec2(-0.5*offseth,-0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(-0.5*offseth,-0.5*offsetv)).xy);\n"
        "    t[1]=vec4(texture2D(pic0, readingPosition+vec2(-0.5*offseth,0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(-0.5*offseth,0.5*offsetv)).xy);\n"
        "    t[2]=vec4(texture2D(pic0, readingPosition+vec2(-0.5*offseth,1.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(-0.5*offseth,1.5*offsetv)).xy);\n"
        "    t[3]=vec4(texture2D(pic0, readingPosition+vec2(0.5*offseth,-0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(0.5*offseth,-0.5*offsetv)).xy);\n"
        "    t[4]=vec4(texture2D(pic0, readingPosition+vec2(0.5*offseth,0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(0.5*offseth,0.5*offsetv)).xy);\n"
        "    t[5]=vec4(texture2D(pic0, readingPosition+vec2(0.5*offseth,1.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(0.5*offseth,1.5*offsetv)).xy);\n"
        "    t[6]=vec4(texture2D(pic0, readingPosition+vec2(1.5*offseth,-0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(1.5*offseth,-0.5*offsetv)).xy);\n"
        "    t[7]=vec4(texture2D(pic0, readingPosition+vec2(1.5*offseth,0.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(1.5*offseth,0.5*offsetv)).xy);\n"
        "    t[8]=vec4(texture2D(pic0, readingPosition+vec2(1.5*offseth,1.5*offsetv)).yz, texture2D(pic1, readingPosition+vec2(1.5*offseth,1.5*offsetv)).xy);\n"
        "    \n"
        "    //multiplicative factors are added to normalize, according to VLfeat\n"
        "    \n"
        "    mediump float Dxx = (t[7]+t[1]-2.0*t[4])[scale];\n"
        "    mediump float Dyy = (t[5]+t[3]-2.0*t[4])[scale];\n"
        "    \n"
        "    mediump float Dxy = 0.25*(t[8]+t[0]-t[2]-t[6])[scale];\n"
        "    \n"
        "    //Edge Thresholding\n"
        "    if ((Dxx+Dyy)*(Dxx+Dyy)/(Dxx*Dyy-Dxy*Dxy)>(thresEdge+1.0)*(thresEdge+1.0)/thresEdge) {\n"
        "        gl_FragColor = vec4(1.0);\n"
        "    }\n"
        "    else {\n"
        "        gl_FragColor = vec4(0.0);\n"
        "    }\n"
        "\n"
        "}";

//fragment shader that computes a [-1 0 1] gradient
static auto gradFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D pic0;\n"
        "uniform lowp sampler2D pic1;\n"
        "uniform mediump float sigma[4];\n"
        "uniform mediump vec2 dir;\n"
        "void main(void)\n"
        "{\n"
        "    lowp vec4 ur = vec4(texture2D(pic0, tCoord + sigma[0]*dir).y, texture2D(pic0, tCoord + sigma[1]*dir).z, texture2D(pic1, tCoord + sigma[2]*dir).x, texture2D(pic1, tCoord + sigma[3]*dir).y);\n"
        "    lowp vec4 dl = vec4(texture2D(pic0, tCoord - sigma[0]*dir).y, texture2D(pic0, tCoord - sigma[1]*dir).z, texture2D(pic1, tCoord - sigma[2]*dir).x, texture2D(pic1, tCoord - sigma[3]*dir).y);\n"
        "    gl_FragColor = (ur-dl+1.0)/2.0;\n"
        "}";

//computes vertical or horizontal gradient
static auto gradientFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D pic0;\n"
        "uniform lowp sampler2D pic1;\n"
        "uniform mediump float sigma[4];\n"
        "uniform mediump vec2 direction;\n"
        "void main(void)\n"
        "{\n"
        "    lowp vec4 ur = vec4(texture2D(pic0, tCoord + sigma[0]*direction).y, texture2D(pic0, tCoord + sigma[1]*direction).z, texture2D(pic1, tCoord + sigma[2]*direction).x, texture2D(pic1, tCoord + sigma[3]*direction).y);\n"
        "    lowp vec4 dl = vec4(texture2D(pic0, tCoord - sigma[0]*direction).y, texture2D(pic0, tCoord - sigma[1]*direction).z, texture2D(pic1, tCoord - sigma[2]*direction).x, texture2D(pic1, tCoord - sigma[3]*direction).y);\n"
        "    gl_FragColor = (ur-dl+1.0)/2.0;\n"
        "}";
//computes the dominant orientation from orientations and magnitude in the region of interest
static auto mainOrientationFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D pic0;\n"
        "uniform int sqSize;\n"
        "void main(void)\n"
        "{\n"
        "    mediump vec2 coord=floor(float(sqSize)*tCoord)/float(sqSize);\n"
        "    mediump float off = 1.0/(16.0*float(sqSize));\n"
        "    \n"
        "    mediump float bins[8];\n"
        "    for (int i=0; i<8; i++) {\n"
        "        bins[i]=0.0;\n"
        "    }\n"
        "    for (int i=0; i<16; i++) {\n"
        "        for (int j=0; j<16; j++) {\n"
        "            mediump vec4 c=texture2D(pic0,coord+vec2(float(i)*off,float(j)*off));\n"
        "            bins[int(mod(floor(c.x*8.0),8.0))]+=c.y;\n"
        "        }\n"
        "    }\n"
        "    \n"
        "    mediump float best = 0.0;\n"
        "    int winner=0;\n"
        "    for (int i=0; i<8; i++) {\n"
        "        if (bins[i]>best) {\n"
        "            best=bins[i];\n"
        "            winner=i;\n"
        "        }\n"
        "    }\n"
        "    //gl_FragColor = vec4(float(winner)/256.0);\n"
        "    lowp vec4 res = vec4(float(winner)/256.0, 1.0, 1.0, 1.0);\n"
        "    int j=1;\n"
        "    for (int i=0; i<8 && j<4; i++) {\n"
        "        if (i!=winner && bins[i]>0.8*best) {\n"
        "            res[j]=float(i)/256.0;\n"
        "            j++;\n"
        "        }\n"
        "    }\n"
        "    gl_FragColor = res;\n"
        "}";

//performs non maxima suppression on DoG response
static auto nmsFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform mediump float width;\n"
        "uniform mediump float height;\n"
        "uniform mediump sampler2D pic0;\n"
        "uniform mediump sampler2D pic1;\n"
        "void main(void)\n"
        "{\n"
        "  mediump float offseth = 1.0/width;\n"
        "  mediump float offsetv = 1.0/height;\n"
        "  \n"
        "  mediump float thres2=0.1; // minimum difference threshold.\n"
        "  mediump vec4 vthres=vec4(2.0);\n"
        "  \n"
        "  mediump vec4 c=vec4(texture2D(pic0, tCoord).yz,texture2D(pic1, tCoord).xy)*255.0;\n"
        "  mediump vec4 t;\n"
        "  \n"
        "  bvec4 max=greaterThan(c,128.0+vthres);\n"
        "  bvec4 min=lessThan(c,128.0-vthres);\n"
        "  mediump vec4 f = vec4(max)-vec4(min);\n"
        "\n"
        "  lowp vec4 r = step(thres2, f*c-f*vec4(c.yzw, texture2D(pic1, tCoord).z*255.0)) * step(thres2, f*c-f*vec4(texture2D(pic0, tCoord).x*255.0, c.xyz));\n"
        "\n"
        "  for (int i=-1; i<2; i++) {\n"
        "    for (int j=-1; j<2; j++) {\n"
        "      if (i!=0 || j!=0) {\n"
        "        t = vec4(texture2D(pic0, tCoord+vec2(float(i)*offseth,float(j)*offsetv)).yz,texture2D(pic1, tCoord+vec2(float(i)*offseth,float(j)*offsetv)).xy)*255.0;\n"
        "        r*= step(thres2, f*c-f*t);\n"
        "        r*= step(thres2, f*c-f*vec4(t.yzw, texture2D(pic1, tCoord+vec2(float(i)*offseth,float(j)*offsetv)).z*255.0));\n"
        "        r*= step(thres2, f*c-f*vec4(texture2D(pic0, tCoord+vec2(float(i)*offseth,float(j)*offsetv)).x*255.0, t.xyz));\n"
        "      }\n"
        "    }\n"
        "  }\n"
        "  gl_FragColor = r;\n"
        "\n"
        "}";
//computes orientation and weighted magnitude from gradients
static auto orientationFragmentShader = "varying mediump vec2 tCoord;\n"
        "varying mediump vec2 tGauss;\n"
        "uniform lowp sampler2D gradx;\n"
        "uniform lowp sampler2D grady;\n"
        "uniform lowp sampler2D gauss;\n"
        "uniform int scale;\n"
        "uniform int theta;\n"
        "void main(void)\n"
        "{\n"
        "  mediump float gx=(texture2D(gradx, tCoord)[scale]-0.5)*2.0;\n"
        "  mediump float gy=(texture2D(grady, tCoord)[scale]-0.5)*2.0;\n"
        "  mediump float theta = mod((atan(gy,gx)+3.5342917353)/6.2831853072-float(theta)/8.0,1.0); //atan()+pi+pi/8 will allow our angle quantization to be axis-aligned\n"
        "  mediump float mag = sqrt(gx*gx+gy*gy)*texture2D(gauss, tGauss).w/1.4142135624;\n"
        "  gl_FragColor = vec4(theta, mag, 0.0, 0.0);\n"
        "}";
//simply displays an image
static auto printerFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D pic;\n"
        "void main(void)\n"
        "{\n"
        "  //gl_FragColor=texture2D(Image, tCoord);\n"
        "  gl_FragColor=vec4(texture2D(pic,tCoord).w);\n"
        "}";
//that computes either vertical or horizontal smoothing, with the same sigma for all channels.
static auto quickBlurFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform lowp sampler2D Image;\n"
        "uniform lowp float Coeff[13];\n"
        "uniform mediump vec2 dir;\n"
        "void main(void)\n"
        "{\n"
        "  mediump float colors[13];\n"
        "  for (int i=0; i<13; i++) {\n"
        "    colors[i]=texture2D(Image, tCoord+(float(i)-6.0)*dir).x;\n"
        "  }\n"
        "  mediump float r=0.0;\n"
        "  for (int i=0; i<13; i++) {\n"
        "    r+=Coeff[i]*colors[i];\n"
        "  }\n"
        "  gl_FragColor = vec4(r);\n"
        "}";

//computes horizontal or vertical smoothing, single pass (approximated)
static auto smoothFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform mediump sampler2D pic;\n"
        "uniform mediump float gaussianCoeff[8];\n"
        "uniform mediump vec2 direction;\n"
        "void main(void)\n"
        "{\n"
        "  mediump vec4 r = gaussianCoeff[0]*texture2D(pic, tCoord);\n"
        "  for (int i=1; i<8; i++) {\n"
        "    r+=gaussianCoeff[i]*texture2D(pic, tCoord+float(i)*direction);\n"
        "    r+=gaussianCoeff[i]*texture2D(pic, tCoord-float(i)*direction);\n"
        "  }\n"
        "  gl_FragColor = r;\n"
        "\n"
        "}";
//computes horizontal or vertical smoothing, in 2 passes.
static auto smoothDoubleFragmentShader = "varying mediump vec2 tCoord;\n"
        "uniform mediump sampler2D pic0;\n"
        "uniform mediump sampler2D pic1;\n"
        "uniform mediump vec4 gaussianCoeff[15];\n"
        "uniform mediump vec2 direction;\n"
        "void main(void)\n"
        "{\n"
        "  mediump vec4 r = gaussianCoeff[0]*texture2D(pic0, tCoord);\n"
        "  for (int i=1; i<8; i++) {\n"
        "    r+=gaussianCoeff[i]*texture2D(pic1, tCoord+float(i)*direction);\n"
        "    r+=gaussianCoeff[i+7]*texture2D(pic1, tCoord+float(i+7)*direction);\n"
        "    \n"
        "  }\n"
        "  gl_FragColor = r;\n"
        "\n"
        "}";

//for applications using the same writing and reading coordinates
static auto vertex = "attribute lowp vec4 writingPosition;\n"
        "attribute mediump vec2 readingPosition; \n"
        "varying mediump vec2 tCoord;\n"
        "void main(void)\n"
        "{\n"
        "  gl_Position = writingPosition;\n"
        "  tCoord=readingPosition;\n"
        "}";
//non reading coordinates, made to works on each pixel individually
static auto vertex0 ="attribute highp vec4 writingPosition;\n"
        "void main(void)\n"
        "{\n"
        "  gl_Position = writingPosition;\n"
        "}";

//for applications using 2 different sets of reading Coordinates
static auto vertex2 ="attribute mediump vec4 writingPosition;\n"
        "attribute mediump vec2 readingPositionGrad; \n"
        "attribute mediump vec2 readingPositionGauss;\n"
        "varying mediump vec2 tCoord;\n"
        "varying mediump vec2 tGauss;\n"
        "void main(void)\n"
        "{\n"
        "  gl_Position = writingPosition;\n"
        "  tCoord=readingPositionGrad;\n"
        "  tGauss=readingPositionGauss;\n"
        "}";



#endif //GPUSIFTANDROID_SHADERS_H
